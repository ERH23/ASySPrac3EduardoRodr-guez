<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>Pr&aacute;ctica3: Se&ntilde;ales Continuas 2MV1</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-03-18">
<meta name="DC.source" content="Practica3.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>Pr&aacute;ctica3: Se&ntilde;ales Continuas 2MV1</h1>
<!--introduction-->
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Integrantes</a>
</li>
<li>
<a href="#3">Objetivo</a>
</li>
<li>
<a href="#5">1.11 MATLAB: Trabajar con funciones</a>
</li>
<li>
<a href="#32">Problema 1.2-2</a>
</li>
<li>
<a href="#36">Problema 1.11-1</a>
</li>
</ul>
</div>
<h2 id="1">Integrantes</h2>
<div>
<ul>
<li>Cruz Cris&oacute;stomo Alejandra Lebafran</li>
<li>Jim&eacute;nez Rivera Emilio</li>
<li>L&oacute;pez Mart&iacute;nez Carlos Ian</li>
<li>Ortiz V&aacute;zquez Piero Ludwig</li>
<li>Rodr&iacute;guez Hern&aacute;ndez Eduardo</li>
</ul>
</div>
<h2 id="3">Objetivo</h2>
<p>Con esta pr&aacute;ctica buscamos obtener y reforzar conocimientos previamente adquiridos, esto por medio de la elaboraci&oacute;n de una p&aacute;gina Web utilizando la plataforma de MATLAB, el cual nos proporcionar&aacute; un mejor dominio de los temas y mayor agilidad para el uso de la plataforma.</p>
<h2 id="5">1.11 MATLAB: Trabajar con funciones</h2>
<p>Trabajar con funciones es fundamental para las aplicaciones de se&ntilde;ales y sistemas. MATLAB proporciona varios m&eacute;todos para definir y evaluar funciones. La comprensi&oacute;n y el uso competente de estos m&eacute;todos son, por tanto, necesarios y beneficiosos.</p>
<p>
<b>1.11-1 Funciones Anonimas</b>
</p>
<p>Muchas funciones simples se representan m&aacute;s convenientemente mediante el uso an&oacute;nimo de MATLAB. Una funci&oacute;n an&oacute;nima proporciona una representaci&oacute;n simb&oacute;lica de una funci&oacute;n definida en t&eacute;rminos de operadores u otras funciones an&oacute;nimas de MATLAB. Por ejemplo, considere definiendo la sinusoide amortiguada exponencialmente <img src="Practica3_eq06265619479204465354.png" alt="$f(t) = e^{-t}cos(2\pi t)$"> .</p>
<pre class="codeinput"> f = @(t) exp(-t).*cos(2*pi*t);
</pre>
<p>En este contexto, el s&iacute;mbolo <b>@</b> identifica la expresi&oacute;n como una funci&oacute;n an&oacute;nima, que se asigna un nombre de <b>f</b>. Los par&eacute;ntesis que siguen al s&iacute;mbolo <b>@</b> se utilizan para identificar la variable independiente (argumentos de entrada), que en este caso es la &uacute;nica variable de tiempo <b>t</b>. Argumentos de entrada, como <b>t</b> , son locales de la funci&oacute;n an&oacute;nima y no est&aacute;n relacionados con ninguna variable del espacio de trabajo con los mismos nombres.</p>
<p>Una vez definida, <b>f(t)</b> se puede evaluar simplemente pasando los valores de entrada de inter&eacute;s. Por ejemplo,</p>
<pre class="codeinput">t = 0; f(t)
</pre>
<pre class="codeoutput">
ans =

     1

</pre>
<p>eval&uacute;a <b>f(t)</b> en <b>t = 0</b> , confirmando el resultado esperado de la unidad. El mismo resultado se obtiene pasando <b>t = 0</b> directamente.</p>
<pre class="codeinput">f(0)
</pre>
<pre class="codeoutput">
ans =

     1

</pre>
<p>Las entradas vectoriales permiten la evaluaci&oacute;n de m&uacute;ltiples valores simult&aacute;neamente. Considere la tarea de trazar <b>f(t)</b> en el intervalo <b>(&minus;2 &le; t &le; 2)</b> . El comportamiento de la funci&oacute;n bruta es claro: <b>f(t)</b> deber&iacute;a oscilar cuatro veces con una envolvente en decadencia. Dado que los bocetos precisos a mano son engorrosos, los gr&aacute;ficos generados por MATLAB son una alternativa atractiva. Como ilustra el siguiente ejemplo, el cuidado es que se deben tomar medidas para garantizar resultados confiables.</p>
<p>Supongamos que se elige el vector <b>t</b> para incluir solo los n&uacute;meros enteros contenidos en <b>(&minus;2 &le; t &le; 2)</b> , es decir, <b>[-2,-1, 0, 1, 2]</b> .</p>
<pre class="codeinput">t = (-2:2);
</pre>
<p>Esta entrada vectorial se eval&uacute;a para formar una salida vectorial.</p>
<pre class="codeinput">f(t)
</pre>
<pre class="codeoutput">
ans =

    7.3891    2.7183    1.0000    0.3679    0.1353

</pre>
<p>El comando plot grafica el resultado, que se muestra en la figura 1.46.</p>
<p>Las l&iacute;neas de cuadr&iacute;cula, agregadas mediante el comando de cuadr&iacute;cula, ayudan a identificar las caracter&iacute;sticas. Desafortunadamente, el gr&aacute;fico no ilustra el comportamiento oscilatorio esperado. Se requieren m&aacute;s puntos para adecuadamente representar <b>f(t)</b>.</p>
<p>La pregunta entonces es &iquest;cu&aacute;ntos puntos son suficientes? Si se eligen muy pocos puntos, la informaci&oacute;n est&aacute; perdida. Si se eligen demasiados puntos, se desperdicia memoria y tiempo. Se necesita un equilibrio. Para funciones oscilatorias, normalmente es adecuado trazar de 20 a 200 puntos por oscilaci&oacute;n. Para el presente en este caso, se elige <b>t</b> para dar 100 puntos por oscilaci&oacute;n.</p>
<pre class="codeinput">t = (-2:2);
</pre>
<p>Nuevamente, la funci&oacute;n se eval&uacute;a y traza.</p>
<pre class="codeinput">plot(t,f(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'f(t)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="Practica3_01.png" alt=""> <p>
<b>Figura 1.46</b> <img src="Practica3_eq06265619479204465354.png" alt="$f(t) = e^{-t}cos(2\pi t)$"> para <b>t = (-2:2)</b>.</p>
<pre class="codeinput">t = (-2:0.01:2);
plot(t,f(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'f(t)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="Practica3_02.png" alt=""> <p>
<b>Figura 1.47</b> <img src="Practica3_eq06265619479204465354.png" alt="$f(t) = e^{-t}cos(2\pi t)$"> para <b>t = (-2:0.01:2)</b>.</p>
<p>El resultado, que se muestra en la figura 1.47, es una descripci&oacute;n precisa de <b>f(t)</b>.</p>
<p>
<b>1.11-2 Operadores relacionales y la funci&oacute;n de paso unitario</b>
</p>
<p>La funci&oacute;n escal&oacute;n unitario <b>u(t)</b> surge naturalmente en muchas situaciones pr&aacute;cticas. Por ejemplo, un escal&oacute;n unitario puede modelar el acto de encender un sistema. Con la ayuda de operadores relacionales, funciones an&oacute;nimas puede representar la funci&oacute;n del escal&oacute;n unitario.</p>
<p>En MATLAB, un operador relacional compara dos elementos. Si la comparaci&oacute;n es cierta, una verdad l&oacute;gica (1) se devuelve. Si la comparaci&oacute;n es falsa, se devuelve un falso l&oacute;gico (0). A veces llamado indicador de funciones, los operadores relacionales indican si una condici&oacute;n es verdadera. Seis operadores relacionales son disponibles: &lt;, &gt;, &lt;=, &gt;=, == y ~=.</p>
<p>La funci&oacute;n del escal&oacute;n unitario se define f&aacute;cilmente usando el operador relacional &gt;=.</p>
<pre class="codeinput">u = @(t) 1.0.*(t&gt;=0);
</pre>
<p>Cualquier funci&oacute;n con una discontinuidad de salto, como el paso unitario, es dif&iacute;cil de trazar. Considere la posibilidad de trazar <b>u(t)</b> usando <b>t = (-2:2)</b>.</p>
<pre class="codeinput">t = (-2:2); plot(t,u(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'u(t)'</span>);
</pre>
<img vspace="5" hspace="5" src="Practica3_03.png" alt=""> <p>
<b>Figura 1.48</b> <b>u(t)</b> para <b>t = (-2:2)</b>.</p>
<p>Dos problemas importantes son evidentes en el gr&aacute;fico resultante, que se muestra en la figura 1.48. Primero, MATLAB escala autom&aacute;ticamente los ejes del gr&aacute;fico para vincular estrechamente los datos. En este caso, normalmente la caracter&iacute;stica deseable oscurece la mayor parte de la trama. En segundo lugar, MATLAB conecta los datos del trazado con l&iacute;neas, haciendo que una verdadera discontinuidad de salto sea dif&iacute;cil de lograr. La resoluci&oacute;n gruesa del vector <b>t</b> enfatiza el efecto al mostrar una l&iacute;nea inclinada err&oacute;nea entre <b>t = &minus;1</b> y <b>t = 0</b>.</p>
<p>El primer problema se corrige ampliando verticalmente el cuadro delimitador con el eje dominio. El segundo problema se reduce, pero no se elimina, sumando puntos al vector <b>t</b>.</p>
<pre class="codeinput">t = (-2:0.01:2); plot(t,u(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'u(t)'</span>);
axis([-2 2 -0.1 1.1]);
</pre>
<img vspace="5" hspace="5" src="Practica3_04.png" alt=""> <p>
<b>Figura 1.49</b> <b>u(t)</b> para <b>t = (-2:0.01:2)</b> con modificaci&oacute;n axis.</p>
<p>El argumento vectorial de cuatro elementos del eje especifica el eje x m&iacute;nimo, el eje x m&aacute;ximo y el eje y m&iacute;nimo, y m&aacute;ximo del eje y, respectivamente. Los resultados mejorados se muestran en la figura 1.49.</p>
<p>Los operadores relacionales se pueden combinar usando AND l&oacute;gico, OR l&oacute;gico y negaci&oacute;n l&oacute;gica: &amp;, | y ~, respectivamente. Por ejemplo, (t&gt;0)&amp;(t&lt;1) y ~((t&lt;=0)|(t&gt;=1)) prueban si <b>0 &lt; t &lt; 1</b>. Para demostrarlo, considere definir y trazar el escal&oacute;n unitario <b>p(t) = u(t) &minus; u(t &minus; 1)</b>, como se muestra en la Figura 1.50:</p>
<pre class="codeinput">p = @(t) 1.0.*((t&gt;=0)&amp;(t&lt;1));
t = (-1:0.01:2); plot(t,p(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'p(t) = u(t)-u(t-1)'</span>);
axis([-1 2 -.1 1.1]);
</pre>
<img vspace="5" hspace="5" src="Practica3_05.png" alt=""> <p>
<b>Figura 1.50</b> <b>p(t) = u(t) - u(t-1)</b> para <b>(-1 &le; t &le; 2)</b>.</p>
<p>Dado que las funciones an&oacute;nimas se pueden construir utilizando otras funciones an&oacute;nimas, podr&iacute;amos utilizar nuestra funci&oacute;n an&oacute;nima de paso unitario previamente definida para definir <b>p(t)</b> como <b>p = @(t) u(t)-u(t-1)</b>.</p>
<p>Para operandos escalares, MATLAB tambi&eacute;n admite dos construcciones l&oacute;gicas de cortocircuito. A el AND l&oacute;gico de cortocircuito se realiza mediante &amp;&amp;, y el OR l&oacute;gico de cortocircuito se realiza mediante. Los operadores l&oacute;gicos de cortocircuito suelen ser m&aacute;s eficientes que los operadores l&oacute;gicos tradicionales porque prueban la segunda parte de la expresi&oacute;n s&oacute;lo cuando es necesario. Es decir, cuando al escalar la expresi&oacute;n A se encuentra falsa en (A&amp;&amp;B), la expresi&oacute;n escalar B no se eval&uacute;a, ya que un resultado falso ya est&aacute; garantizado. De manera similar, la expresi&oacute;n escalar B no se eval&uacute;a cuando la expresi&oacute;n escalar A es encontrado verdadero en (A||B), ya que ya se garantiza un resultado verdadero.</p>
<p>
<b>1.11-3 Visualizaci&oacute;n de operaciones en la variable independiente</b>
</p>
<p>Com&uacute;nmente se encuentran dos operaciones sobre la variable independiente de una funci&oacute;n: desplazamiento y escalada. Las funciones an&oacute;nimas son muy adecuadas para investigar ambas operaciones.</p>
<p>Considere <img src="Practica3_eq04592527024211531935.png" alt="$g(t) = f(t)u(t) = e^{-t}cos(2\pi t)u(t)$">, una versi&oacute;n causal de <b>f(t)</b>. MATLAB f&aacute;cilmente multiplica funciones an&oacute;nimas. Por lo tanto, creamos <b>g(t)</b> multiplicando nuestras funciones an&oacute;nimas para <b>f(t)</b> y <b>u(t)</b>.</p>
<pre class="codeinput">g = @(t) f(t).*u(t);
</pre>
<p>Una operaci&oacute;n combinada de cambio y escala est&aacute; representada por <b>g(at + b)</b>, donde a y b son constantes reales arbitrarias. Como ejemplo, considere graficar <b>g(2t +1)</b> sobre <b>(&minus;2 &le; t &le; 2)</b> . Con <b>a = 2</b>, la funci&oacute;n se comprime por un factor de 2, lo que da como resultado el doble de oscilaciones por unidad <b>t</b>. A&ntilde;adiendo la condici&oacute;n <b>b &gt; 0</b> desplaza la forma de onda hacia la izquierda. Dada la funci&oacute;n an&oacute;nima <b>g</b>, una gr&aacute;fica precisa es casi trivial de obtener.</p>
<pre class="codeinput">t = (-2:0.01:2);
plot(t,g(2*t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'g(2t+1)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="Practica3_06.png" alt=""> <p>
<b>Figura 1.51 g(2t +1)</b> para <b>(&minus;2 &le; t &le; 2)</b>.</p>
<p>La Figura 1.51 confirma la compresi&oacute;n esperada de la forma de onda y el desplazamiento hacia la izquierda. Como comprobaci&oacute;n final, tenga en cuenta esa funci&oacute;n g(&middot;) se activa cuando el argumento de entrada es cero. Por lo tanto, <b>g(2t + 1)</b> deber&iacute;a activarse cuando <b>2t +1 = 0</b> o en <b>t = &minus;0.5</b>, hecho confirmado nuevamente por la figura 1.51</p>
<pre class="codeinput">t = (-2:0.01:2);
plot(t,g(-t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'g(-t+1)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="Practica3_07.png" alt=""> <p>
<b>Figura 1.52 g(-t +1)</b> para <b>(&minus;2 &le; t &le; 2)</b>.</p>
<pre class="codeinput">t = (-2:0.01:2);
plot(t,g(2*t+1)+g(-t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'g(2t+1)+g(-t+1)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="Practica3_08.png" alt=""> <p>
<b>Figura 1.53 h(t) = g(2t+1) + g(-t+1)</b> para <b>(&minus;2 &le; t &le; 2)</b>.</p>
<p>A continuaci&oacute;n, considere graficar <b>g(&minus;t + 1)</b> sobre <b>(&minus;2 &le; t &le; 2)</b>. Como <b>a &lt; 0</b>, la forma de onda ser&aacute; reflejado. Agregar la condici&oacute;n <b>b &gt; 0</b> que desplaza la forma de onda final hacia la derecha.</p>
<pre class="codeinput">plot(t,g(-t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'g(-t+1)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="Practica3_09.png" alt=""> <p>La figura 1.52 confirma tanto la reflexi&oacute;n como el desplazamiento a la derecha.</p>
<p>Hasta este punto, las Figuras 1.51 y 1.52 podr&iacute;an esbozarse razonablemente a mano. Considere la posibilidad de trazar la funci&oacute;n m&aacute;s complicada <b>h(t) = g(2t + 1) + g(&minus;t + 1)</b> sobre <b>(&minus;2 &le; t &le; 2)</b> (figura 1.53); un boceto a mano preciso ser&iacute;a bastante dif&iacute;cil. Con MATLAB, el trabajo es mucho menos engorroso.</p>
<pre class="codeinput">plot(t,g(2*t+1)+g(-t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'h(t)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="Practica3_10.png" alt=""> <p>
<b>1.11-4 Integraci&oacute;n num&eacute;rica y estimaci&oacute;n de la energ&iacute;a de una se&ntilde;al.</b>
</p>
<p>Las se&ntilde;ales interesantes suelen tener representaciones matem&aacute;ticas no triviales. Computar la energ&iacute;a de la se&ntilde;al, que implica integrar el cuadrado de estas expresiones, puede ser una tarea desalentadora. Afortunadamente, muchas integrales dif&iacute;ciles se pueden estimar con precisi&oacute;n mediante t&eacute;cnicas de integraci&oacute;n num&eacute;rica.</p>
<p>Incluso si la integraci&oacute;n parece simple, la integraci&oacute;n num&eacute;rica proporciona una buena manera de verificar resultados anal&iacute;ticos.</p>
<p>Para empezar, considere la se&ntilde;al simple <img src="Practica3_eq15129271055477762288.png" alt="$x(t) = e^{-t}(u(t)-u(t-1))$"> La energ&iacute;a de <b>x(t)</b> se expresa como <img src="Practica3_eq12006230568472885093.png" alt="$ Ex = \int_{-\infty}^{\infty} |x(t)|^2 dt $"> La integraci&oacute;n produce <img src="Practica3_eq07490830411665716650.png" alt="$ Ex = 0.5(1-e^{-2}) \approx 0.4323$">. La energ&iacute;a de la integral tambi&eacute;n se puede evaluar num&eacute;ricamente. La figura 1.27 ayuda a ilustrar el m&eacute;todo simple de aproximaci&oacute;n rectangular: eval&uacute;e el integrando en puntos separados uniformemente por <img src="Practica3_eq00791438275661894543.png" alt="$\Delta t$">, multiplique cada uno por <img src="Practica3_eq00791438275661894543.png" alt="$\Delta t$"> para calcular las &aacute;reas del rect&aacute;ngulo y luego sumar todos los rect&aacute;ngulos. Primero, creamos la funci&oacute;n <b>x(t)</b>.</p>
<pre class="codeinput">x = @(t) exp(-t).*((t&gt;=0)&amp;(t&lt;1));
</pre>
<p>Con <img src="Practica3_eq15810582725536873355.png" alt="$\Delta t = 0.01$">, se crea un vector de tiempo adecuado.</p>
<pre class="codeinput">t = (0:0.01:1);
</pre>
<p>El resultado final se calcula utilizando el comando suma.</p>
<pre class="codeinput">E_x = sum(x(t).*x(t)*0.01)
</pre>
<pre class="codeoutput">
E_x =

    0.4367

</pre>
<p>El resultado no es perfecto, pero con un error relativo del 1% est&aacute; cerca. Reduciendo <img src="Practica3_eq00791438275661894543.png" alt="$\Delta t$">, la aproximaci&oacute;n es mejorado. Por ejemplo, <b>t = 0.001</b> produce <b>E_x = 0.4328</b>, o un error relativo del 0.1%.</p>
<p>Aunque es f&aacute;cil de visualizar, la aproximaci&oacute;n rectangular no es la mejor integraci&oacute;n num&eacute;rica t&eacute;cnica. La funci&oacute;n quad de MATLAB implementa una mejor t&eacute;cnica de integraci&oacute;n num&eacute;rica llamada <b>cuadratura de Simpson adaptativa recursiva</b>. Para operar, <b>quad</b> requiere una funci&oacute;n que describa el integrando, el l&iacute;mite inferior de integraci&oacute;n y el l&iacute;mite superior de integraci&oacute;n. Observe que <img src="Practica3_eq00791438275661894543.png" alt="$\Delta t$"> no necesita ser especificado</p>
<p>Para utilizar <b>quad</b> para estimar <b>Ex</b>, primero se debe describir el integrando.</p>
<pre class="codeinput">x_squared = @(t) x(t).*x(t);
</pre>
<p>La estimaci&oacute;n de <b>Ex</b> sigue inmediatamente.</p>
<pre class="codeinput">E_x = quad(x_squared,0,1)
</pre>
<pre class="codeoutput">
E_x =

    0.4323

</pre>
<p>En este caso, el error relativo es de &minus;0.0026%.</p>
<p>Se pueden utilizar las mismas t&eacute;cnicas para estimar la energ&iacute;a de se&ntilde;ales m&aacute;s complejas. Considerar <b>g(t)</b>, definido anteriormente. La energ&iacute;a se expresa como <img src="Practica3_eq18287553746590236862.png" alt="$ Eg = \int_{0}^{\infty} e^{-2t}cos(2\pi t)dt $">. Una soluci&oacute;n de forma cerrada existe, pero requiere algo de esfuerzo. MATLAB proporciona una respuesta m&aacute;s r&aacute;pidamente.</p>
<pre class="codeinput">g_squared = @(t) g(t).*g(t);
</pre>
<p>Aunque el l&iacute;mite superior de integraci&oacute;n es infinito, la envolvente que decae exponencialmente asegura <b>g(t)</b> es efectivamente cero mucho antes de <b>t = 100</b>. Por lo tanto, se utiliza un l&iacute;mite superior de <b>t = 100</b> junto con <img src="Practica3_eq04091242478022550198.png" alt="$\Delta t = 0.001$">.</p>
<pre class="codeinput">t = (0:0.001:100);
E_g = sum(g_squared(t)*0.001)
</pre>
<pre class="codeoutput">
E_g =

    0.2567

</pre>
<p>Se obtiene una aproximaci&oacute;n ligeramente mejor con la funci&oacute;n <b>quad</b>.</p>
<pre class="codeinput">E_g = quad(g_squared,0,100)
</pre>
<pre class="codeoutput">
E_g =

    0.2562

</pre>
<h2 id="32">Problema 1.2-2</h2>
<p>1.2-2 Para la se&ntilde;al x(t) mostrada a continuaci&oacute;n bosqueje lo siguiente:</p>
<div>
<ul>
<li>a) x(t-4)</li>
<li>b) x(t/1.5)</li>
<li>c) x(-t)</li>
<li>d) x(2t-4)</li>
<li>e) x(2-t)</li>
</ul>
</div>
<pre class="codeinput">t = (-5:0.01:3);
x1 = @(t) -t.*((t&gt;=-4)&amp;(t&lt;=0));
x2 = @(t) t.*((t&gt;=0)&amp;(t&lt;=2));
x = @(t) x1(t) + x2(t);
figure()
plot(t,x(t),LineWidth=1.5);
grid <span class="string">on</span>;
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">'off'</span>;
title(<span class="string">'x(t)'</span>)
</pre>
<img vspace="5" hspace="5" src="Practica3_11.png" alt=""> <pre class="codeinput">
<span class="comment">%Respuesta</span>
figure();
subplot(3,2,1)
t1 = (-1:0.01:7);
plot(t1,x(t1-4),LineWidth=1.5);
grid <span class="string">on</span>;
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">"off"</span>;
axis([-1 7 0 4]); title(<span class="string">'a) x(t-4)'</span>);

subplot(3,2,2);
t2 = (-7:0.01:4);
plot(t2,x(t2/1.5),LineWidth=1.5);
grid <span class="string">on</span>;
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">"off"</span>;
axis([-7 4 0 4]); title(<span class="string">'b) x(t/1.5)'</span>);

subplot(3,2,3);
t3 = (-3:0.01:5);
plot(t3,x(-t3),LineWidth=1.5);
grid <span class="string">on</span>;
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">"off"</span>;
axis([-3 5 0 4]); title(<span class="string">'c) x(-t)'</span>)

subplot(3,2,4);
t4 = (-1:0.01:4);
plot(t4,x((2.*t4)-4),LineWidth=1.5);
grid <span class="string">on</span>;
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">"off"</span>;
axis([-1 4 0 4]); title(<span class="string">'d) x(2t-4)'</span>)

subplot(3,2,5);
t5 = (-1:0.01:7);
plot(t5,x(2-t5),LineWidth=1.5);
grid <span class="string">on</span>;
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">"off"</span>;
axis([-1 7 0 4]); title(<span class="string">'e) x(2-t)'</span>)
</pre>
<img vspace="5" hspace="5" src="Practica3_12.png" alt=""> <h2 id="36">Problema 1.11-1</h2>
<p>1.11-1 Proporcionar c&oacute;digo MATLAB y resultados que tracen la porci&oacute;n impar xe(t) de la funci&oacute;n <img src="Practica3_eq13566386619642843178.png" alt="$x(t) = 2^{-t}cos(2\pi t)u(t-\pi)$"> en un intervalo de longitud adecuada utilizando un n&uacute;mero adecuado de puntos.</p>
<pre class="codeinput">figure();
t = (0:0.1:10);
u = @(t) 1.0.*(t&gt;=0);
x = @(t) ((2.^(-t)).*cos(4*pi*t)).*u(t-pi);
plot(t,x(t),<span class="string">'--r'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x(t)'</span>);
grid <span class="string">on</span>;
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">'off'</span>;
title(<span class="string">'Gr&aacute;fica de problema 1.11-1'</span>);
</pre>
<img vspace="5" hspace="5" src="Practica3_13.png" alt=""> <p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Práctica3: Señales Continuas 2MV1
%% Integrantes
%%
% 
% * Cruz Crisóstomo Alejandra Lebafran
% * Jiménez Rivera Emilio
% * López Martínez Carlos Ian
% * Ortiz Vázquez Piero Ludwig
% * Rodríguez Hernández Eduardo 
% 

%% Objetivo
%
% Con esta práctica buscamos obtener y reforzar conocimientos
% previamente adquiridos, esto por medio de la elaboración de una página
% Web utilizando la plataforma de MATLAB, el cual nos proporcionará un
% mejor dominio de los temas y mayor agilidad para el uso de la plataforma.
%%
%% 1.11 MATLAB: Trabajar con funciones
% Trabajar con funciones es fundamental para las aplicaciones de señales y sistemas. MATLAB proporciona
% varios métodos para definir y evaluar funciones. La comprensión y el uso competente de estos
% métodos son, por tanto, necesarios y beneficiosos.
%
% *1.11-1 Funciones Anonimas* 
%
% Muchas funciones simples se representan más convenientemente mediante el uso anónimo de MATLAB.
% Una función anónima proporciona una representación simbólica de una función definida en
% términos de operadores u otras funciones anónimas de MATLAB. Por ejemplo, considere
% definiendo la sinusoide amortiguada exponencialmente $f(t) = e^{-t}cos(2\pi t)$ .
%
 f = @(t) exp(-t).*cos(2*pi*t);
%%
% En este contexto, el símbolo *@* identifica la expresión como una función anónima, que se asigna
% un nombre de *f*. Los paréntesis que siguen al símbolo *@* se utilizan para identificar la variable independiente
% (argumentos de entrada), que en este caso es la única variable de tiempo *t*. Argumentos de entrada, como
% *t* , son locales de la función anónima y no están relacionados con
% ninguna variable del espacio de trabajo con los
% mismos nombres.
%
% Una vez definida, *f(t)* se puede evaluar simplemente pasando los valores
% de entrada de interés. Por ejemplo,
%
t = 0; f(t)
%%
% evalúa *f(t)* en *t = 0* , confirmando el resultado esperado de la unidad. El mismo resultado se obtiene
% pasando *t = 0* directamente.
%
f(0)
%%
% Las entradas vectoriales permiten la evaluación de múltiples valores simultáneamente. Considere la tarea
% de trazar *f(t)* en el intervalo *(−2 ≤ t ≤ 2)* . El comportamiento de la función bruta es claro: *f(t)* debería
% oscilar cuatro veces con una envolvente en decadencia. Dado que los bocetos precisos a mano son engorrosos,
% los gráficos generados por MATLAB son una alternativa atractiva. Como ilustra el siguiente ejemplo, el cuidado
% es que se deben tomar medidas para garantizar resultados confiables.
%
% Supongamos que se elige el vector *t* para incluir solo los números enteros contenidos en *(−2 ≤ t ≤ 2)* , es decir,
% *[-2,-1, 0, 1, 2]* .
%
t = (-2:2);
%%
% Esta entrada vectorial se evalúa para formar una salida vectorial.
%
f(t)
%%
% El comando plot grafica el resultado, que se muestra en la figura 1.46.
%
% Las líneas de cuadrícula, agregadas mediante el comando de cuadrícula, ayudan a identificar las características. Desafortunadamente, el
% gráfico no ilustra el comportamiento oscilatorio esperado. Se requieren más puntos para adecuadamente
% representar *f(t)*.
%
% La pregunta entonces es ¿cuántos puntos son suficientes? Si se eligen muy pocos puntos, la información
% está perdida. Si se eligen demasiados puntos, se desperdicia memoria y tiempo. Se necesita un equilibrio. Para
% funciones oscilatorias, normalmente es adecuado trazar de 20 a 200 puntos por oscilación. Para el presente
% en este caso, se elige *t* para dar 100 puntos por oscilación.
%
t = (-2:2);
%%
% Nuevamente, la función se evalúa y traza.
plot(t,f(t));
xlabel('t'); ylabel('f(t)'); grid;
%%
% *Figura 1.46* $f(t) = e^{-t}cos(2\pi t)$ para *t = (-2:2)*.
%
t = (-2:0.01:2);
plot(t,f(t));
xlabel('t'); ylabel('f(t)'); grid;
%%
% *Figura 1.47* $f(t) = e^{-t}cos(2\pi t)$ para *t = (-2:0.01:2)*.
%
% El resultado, que se muestra en la figura 1.47, es una descripción precisa de *f(t)*.
%
% *1.11-2 Operadores relacionales y la función de paso unitario* 
%
% La función escalón unitario *u(t)* surge naturalmente en muchas situaciones prácticas. Por ejemplo, un escalón unitario puede
% modelar el acto de encender un sistema. Con la ayuda de operadores relacionales, funciones anónimas
% puede representar la función del escalón unitario.
%
% En MATLAB, un operador relacional compara dos elementos. Si la comparación es cierta, una verdad lógica
% (1) se devuelve. Si la comparación es falsa, se devuelve un falso lógico (0). A veces llamado indicador de
% funciones, los operadores relacionales indican si una condición es verdadera. Seis operadores relacionales son
% disponibles: <, >, <=, >=, == y ~=.
% 
% La función del escalón unitario se define fácilmente usando el operador
% relacional >=.
%
u = @(t) 1.0.*(t>=0);
%%
% Cualquier función con una discontinuidad de salto, como el paso unitario, es difícil de trazar. Considere la posibilidad de trazar
% *u(t)* usando *t = (-2:2)*.
%
t = (-2:2); plot(t,u(t));
xlabel('t'); ylabel('u(t)');
%%
% *Figura 1.48* *u(t)* para *t = (-2:2)*.
%
% Dos problemas importantes son evidentes en el gráfico resultante, que se muestra en la figura 1.48. Primero,
% MATLAB escala automáticamente los ejes del gráfico para vincular estrechamente los datos. En este caso, normalmente
% la característica deseable oscurece la mayor parte de la trama. En segundo lugar, MATLAB conecta los datos del trazado con líneas,
% haciendo que una verdadera discontinuidad de salto sea difícil de lograr. La resolución gruesa del vector *t* enfatiza
% el efecto al mostrar una línea inclinada errónea entre *t = −1* y *t = 0*.
%
% El primer problema se corrige ampliando verticalmente el cuadro delimitador con el eje
% dominio. El segundo problema se reduce, pero no se elimina, sumando puntos al vector *t*.
%
t = (-2:0.01:2); plot(t,u(t));
xlabel('t'); ylabel('u(t)');
axis([-2 2 -0.1 1.1]);
%%
% *Figura 1.49* *u(t)* para *t = (-2:0.01:2)* con modificación axis.
%
% El argumento vectorial de cuatro elementos del eje especifica el eje x mínimo, el eje x máximo y el eje y
% mínimo, y máximo del eje y, respectivamente. Los resultados mejorados se muestran en la figura 1.49.
%
% Los operadores relacionales se pueden combinar usando AND lógico, OR lógico y negación lógica: &,
% | y ~, respectivamente. Por ejemplo, (t>0)&(t<1) y ~((t<=0)|(t>=1)) prueban si *0 < t < 1*.
% Para demostrarlo, considere definir y trazar el escalón unitario *p(t) = u(t) − u(t − 1)*, como se muestra en la
% Figura 1.50:
%
p = @(t) 1.0.*((t>=0)&(t<1));
t = (-1:0.01:2); plot(t,p(t));
xlabel('t'); ylabel('p(t) = u(t)-u(t-1)');
axis([-1 2 -.1 1.1]);
%%
% *Figura 1.50* *p(t) = u(t) - u(t-1)* para *(-1 ≤ t ≤ 2)*.
%
% Dado que las funciones anónimas se pueden construir utilizando otras funciones anónimas, podríamos
% utilizar nuestra función anónima de paso unitario previamente
% definida para definir *p(t)* como *p = @(t) u(t)-u(t-1)*.
%
% Para operandos escalares, MATLAB también admite dos construcciones lógicas de cortocircuito. A
% el AND lógico de cortocircuito se realiza mediante &&, y el OR lógico de cortocircuito se realiza mediante
% ||. Los operadores lógicos de cortocircuito suelen ser más eficientes que los operadores lógicos tradicionales
% porque prueban la segunda parte de la expresión sólo cuando es necesario. Es decir, cuando al escalar
% la expresión A se encuentra falsa en (A&&B), la expresión escalar B no se evalúa, ya que un resultado falso
% ya está garantizado. De manera similar, la expresión escalar B no se evalúa cuando la expresión escalar A es
% encontrado verdadero en (A||B), ya que ya se garantiza un resultado verdadero.
%
% *1.11-3 Visualización de operaciones en la variable independiente*
%
% Comúnmente se encuentran dos operaciones sobre la variable independiente de una función: desplazamiento y
% escalada. Las funciones anónimas son muy adecuadas para investigar ambas operaciones.
%
% Considere $g(t) = f(t)u(t) = e^{-t}cos(2\pi t)u(t)$, una versión causal de *f(t)*. MATLAB fácilmente
% multiplica funciones anónimas. Por lo tanto, creamos *g(t)* multiplicando nuestras funciones anónimas
% para *f(t)* y *u(t)*.
%
g = @(t) f(t).*u(t);
%%
% Una operación combinada de cambio y escala está representada por *g(at + b)*, donde a y b son
% constantes reales arbitrarias. Como ejemplo, considere graficar *g(2t +1)* sobre *(−2 ≤ t ≤ 2)* . Con *a = 2*,
% la función se comprime por un factor de 2, lo que da como resultado el doble de oscilaciones por unidad *t*. Añadiendo
% la condición *b > 0* desplaza la forma de onda hacia la izquierda. Dada la función anónima *g*, una gráfica precisa
% es casi trivial de obtener.
%
t = (-2:0.01:2);
plot(t,g(2*t+1)); xlabel('t'); ylabel('g(2t+1)'); grid;
%%
% *Figura 1.51 g(2t +1)* para *(−2 ≤ t ≤ 2)*.
%
% La Figura 1.51 confirma la compresión esperada de la forma de onda y el desplazamiento hacia la izquierda. Como comprobación final, tenga en cuenta
% esa función g(·) se activa cuando el argumento de entrada es cero. Por lo tanto, *g(2t + 1)* debería activarse
% cuando *2t +1 = 0* o en *t = −0.5*, hecho confirmado nuevamente por la figura 1.51
%
t = (-2:0.01:2);
plot(t,g(-t+1)); xlabel('t'); ylabel('g(-t+1)'); grid;
%%
% *Figura 1.52 g(-t +1)* para *(−2 ≤ t ≤ 2)*.
%
t = (-2:0.01:2);
plot(t,g(2*t+1)+g(-t+1)); xlabel('t'); ylabel('g(2t+1)+g(-t+1)'); grid;
%%
% *Figura 1.53 h(t) = g(2t+1) + g(-t+1)* para *(−2 ≤ t ≤ 2)*.
%
% A continuación, considere graficar *g(−t + 1)* sobre *(−2 ≤ t ≤ 2)*. Como *a < 0*, la forma de onda será
% reflejado. Agregar la condición *b > 0* que desplaza la forma de onda final hacia la derecha.
%
plot(t,g(-t+1)); xlabel('t'); ylabel('g(-t+1)'); grid;
%%
% La figura 1.52 confirma tanto la reflexión como el desplazamiento a la derecha.
%
% Hasta este punto, las Figuras 1.51 y 1.52 podrían esbozarse razonablemente a mano. Considere la posibilidad de trazar
% la función más complicada *h(t) = g(2t + 1) + g(−t + 1)* sobre *(−2 ≤ t ≤ 2)* (figura 1.53); un
% boceto a mano preciso sería bastante difícil. Con MATLAB, el trabajo es mucho menos engorroso.
%
plot(t,g(2*t+1)+g(-t+1)); xlabel('t'); ylabel('h(t)'); grid;
%%
% *1.11-4 Integración numérica y estimación de la energía de una señal.*
%
% Las señales interesantes suelen tener representaciones matemáticas no triviales. Computar la energía de la señal,
% que implica integrar el cuadrado de estas expresiones, puede ser una tarea desalentadora. Afortunadamente,
% muchas integrales difíciles se pueden estimar con precisión mediante técnicas de integración numérica.
%
% Incluso si la integración parece simple, la integración numérica proporciona una buena manera de verificar
% resultados analíticos.
%
% Para empezar, considere la señal simple $x(t) = e^{-t}(u(t)-u(t-1))$ La energía de *x(t)* se expresa
% como $$ Ex = \int_{-\infty}^{\infty} |x(t)|^2 dt $$ La integración produce $$ Ex = 0.5(1-e^{-2}) \approx 0.4323$$. La energía
% de la integral también se puede evaluar numéricamente. La figura 1.27 ayuda a ilustrar el método simple de
% aproximación rectangular: evalúe el integrando en puntos separados uniformemente por $\Delta t$, multiplique
% cada uno por $\Delta t$ para calcular las áreas del rectángulo y luego sumar todos los rectángulos. Primero, creamos la función
% *x(t)*.
% 
x = @(t) exp(-t).*((t>=0)&(t<1));
%%
% Con $\Delta t = 0.01$, se crea un vector de tiempo adecuado.
%
t = (0:0.01:1);
%%
% El resultado final se calcula utilizando el comando suma.
%
E_x = sum(x(t).*x(t)*0.01)
%%
% El resultado no es perfecto, pero con un error relativo del 1% está cerca. Reduciendo $\Delta t$, la aproximación es
% mejorado. Por ejemplo, *t = 0.001* produce *E_x = 0.4328*, o un error relativo del 0.1%.
%
% Aunque es fácil de visualizar, la aproximación rectangular no es la mejor integración numérica
% técnica. La función quad de MATLAB implementa una mejor técnica de integración numérica
% llamada *cuadratura de Simpson adaptativa recursiva*. Para operar, *quad* requiere una función que describa
% el integrando, el límite inferior de integración y el límite superior de integración. Observe que $\Delta t$ no
% necesita ser especificado
%
% Para utilizar *quad* para estimar *Ex*, primero se debe describir el integrando.
%
x_squared = @(t) x(t).*x(t);
%%
% La estimación de *Ex* sigue inmediatamente.
%
E_x = quad(x_squared,0,1)
%%
% En este caso, el error relativo es de −0.0026%.
%
% Se pueden utilizar las mismas técnicas para estimar la energía de señales más complejas. Considerar
% *g(t)*, definido anteriormente. La energía se expresa como $$ Eg = \int_{0}^{\infty} e^{-2t}cos(2\pi t)dt $$. Una solución de forma cerrada
% existe, pero requiere algo de esfuerzo. MATLAB proporciona una respuesta
% más rápidamente.
%
g_squared = @(t) g(t).*g(t);
%%
% Aunque el límite superior de integración es infinito, la envolvente que decae exponencialmente asegura
% *g(t)* es efectivamente cero mucho antes de *t = 100*. Por lo tanto, se utiliza un límite superior de *t = 100* junto con
% $\Delta t = 0.001$.
%
t = (0:0.001:100);
E_g = sum(g_squared(t)*0.001)
%%
% Se obtiene una aproximación ligeramente mejor con la función *quad*.
%
E_g = quad(g_squared,0,100)
%%
%% Problema 1.2-2
%
% 1.2-2 Para la señal x(t) mostrada a continuación bosqueje lo siguiente:
%
% * a) x(t-4)
% * b) x(t/1.5)
% * c) x(-t)
% * d) x(2t-4)
% * e) x(2-t)
%

t = (-5:0.01:3);
x1 = @(t) -t.*((t>=-4)&(t<=0));
x2 = @(t) t.*((t>=0)&(t<=2));
x = @(t) x1(t) + x2(t);
figure()
plot(t,x(t),LineWidth=1.5);
grid on;
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = 'off';
title('x(t)')
%%
%Respuesta
figure();
subplot(3,2,1)
t1 = (-1:0.01:7);
plot(t1,x(t1-4),LineWidth=1.5);
grid on;
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = "off";
axis([-1 7 0 4]); title('a) x(t-4)');

subplot(3,2,2);
t2 = (-7:0.01:4);
plot(t2,x(t2/1.5),LineWidth=1.5);
grid on;
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = "off";
axis([-7 4 0 4]); title('b) x(t/1.5)');

subplot(3,2,3);
t3 = (-3:0.01:5);
plot(t3,x(-t3),LineWidth=1.5);
grid on;
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = "off";
axis([-3 5 0 4]); title('c) x(-t)')

subplot(3,2,4);
t4 = (-1:0.01:4);
plot(t4,x((2.*t4)-4),LineWidth=1.5);
grid on;
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = "off";
axis([-1 4 0 4]); title('d) x(2t-4)')

subplot(3,2,5);
t5 = (-1:0.01:7);
plot(t5,x(2-t5),LineWidth=1.5);
grid on;
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = "off";
axis([-1 7 0 4]); title('e) x(2-t)')
%%
%%
%% Problema 1.11-1
%
% 1.11-1 Proporcionar código MATLAB y resultados que tracen la porción impar xe(t) de la función $x(t) = 2^{-t}cos(2\pi t)u(t-\pi)$
% en un intervalo de longitud adecuada utilizando un número adecuado de puntos.
figure();
t = (0:0.1:10);
u = @(t) 1.0.*(t>=0);
x = @(t) ((2.^(-t)).*cos(4*pi*t)).*u(t-pi);
plot(t,x(t),'REPLACE_WITH_DASH_DASHr'); xlabel('t'); ylabel('x(t)');
grid on;
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = 'off';
title('Gráfica de problema 1.11-1');
%%

##### SOURCE END #####
-->
</body>
</html>
